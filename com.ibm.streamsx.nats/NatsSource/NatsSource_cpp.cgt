/* Additional includes go here */

#include <stdio.h>
#include <stdlib.h>

<%SPL::CodeGen::implementationPrologue($model);%>

// Constructor
MY_OPERATOR::MY_OPERATOR()
{
}

// Destructor
MY_OPERATOR::~MY_OPERATOR()
{
}

// Notify port readiness
void MY_OPERATOR::allPortsReady()
{
    createThreads(1);
}

// Notify pending shutdown
void MY_OPERATOR::prepareToShutdown()
{
}

<%

my $outputAttribute = "";
if (defined $model->getOutputPortAt(0)) {
    sub getOutputAttribute {
        my $outputPort = $model->getOutputPortAt(0);

        for my $attribute (@{$outputPort->getAttributes()}) {
            if (SPL::CodeGen::Type::isBlob($attribute->getSPLType())) {
                return $attribute->getName();
            }
        }

        die("No blob attribute on output port");
    }

    $outputAttribute = getOutputAttribute();
} else {
    die("Need to have an output port attached");
}

%>

// Processing for source and threaded operators
void MY_OPERATOR::process(uint32_t idx)
{
  // set up the initial connection
  std::string hostname = <%=$model->getParameterByName("hostname")->getValueAt(0)->getCppExpression()%>;
  int port = <%=$model->getParameterByName("port")->getValueAt(0)->getCppExpression()%>;
  // TODO fail if port is out of bounds

  char * portString = new char[6];
  memset(portString, 0, 6);
  snprintf(portString, 6, "%d", port);

  <% if (defined $model->getParameterByName("token")) { %>

  std::string url = <%=$model->getParameterByName("connectionString")->getValueAt(0)->getCppExpression()%>;

  std::string token = <%=$model->getParameterByName("token")->getValueAt(0)->getCppExpression()%>;
  std::string url = "nats://" + token + "@" + hostname + ":" + std::string(portString);

  <% } else { %>

  std::string url = "nats://" + hostname + ":" + std::string(portString);

  <% } %>

  natsConnection_ConnectTo(&(this->conn), url.c_str());

  <% my $subject = $model->getParameterByName("subject")->getValueAt(0)->getCppExpression(); %>
  <% if (defined $model->getParameterByName("queueGroup")) { %>

  std::string queueGroup = <%=$model->getParameterByName("queueGroup")->getValueAt(0)->getCppExpression()%>;
  natsConnection_QueueSubscribeSync(&(this->sub), this->conn, <%=$subject%>.c_str(), queueGroup.c_str());

  <% } else { %>

  natsConnection_SubscribeSync(&(this->sub), this->conn, <%=$subject%>.c_str());

  <% } %>

  natsStatus status;
  OPort0Type outTuple;
  while(!getPE().getShutdownRequested()) {
      status = natsSubscription_NextMsg(&(this->msg), this->sub, 1000);

      if (status == NATS_OK && this->msg != NULL) {
          const char * data = natsMsg_GetData(this->msg);
          int dataLength = natsMsg_GetDataLength(this->msg);
          outTuple.set_<%=$outputAttribute%>(SPL::blob((unsigned char *) data, dataLength));
          submit(outTuple, 0);
      }

      natsMsg_Destroy(this->msg);
      this->msg = NULL;
  }

  natsSubscription_Unsubscribe(this->sub);
  natsSubscription_Destroy(this->sub);

  natsConnection_Destroy(this->conn);
}

// Tuple processing for mutating ports
void MY_OPERATOR::process(Tuple & tuple, uint32_t port)
{
}

// Tuple processing for non-mutating ports
void MY_OPERATOR::process(Tuple const & tuple, uint32_t port)
{
}

// Punctuation processing
void MY_OPERATOR::process(Punctuation const & punct, uint32_t port)
{
}

<%SPL::CodeGen::implementationEpilogue($model);%>

